<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 10. Developer's Guide</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Reconnoiter"><link rel="up" href="pt04.html" title="Part IV. Development"><link rel="prev" href="pt04.html" title="Part IV. Development"><link rel="next" href="reference.html" title="Part V. Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 10. Developer's Guide</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pt04.html">Prev</a> </td><th width="60%" align="center">Part IV. Development</th><td width="20%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dev.reconnoiter"></a>Chapter 10. Developer's Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="dev.reconnoiter.html#dev.reconnoiter.internal">Internal APIs</a></span></dt><dt><span class="section"><a href="dev.reconnoiter.html#idm59688334048">Hooks</a></span></dt><dt><span class="section"><a href="dev.reconnoiter.html#idm59688309152">Developing modules in C</a></span></dt><dt><span class="section"><a href="dev.reconnoiter.html#idm59688296448">Developing modules in lua</a></span></dt><dt><span class="section"><a href="dev.reconnoiter.html#idm59688107888">Developing modules in Java</a></span></dt></dl></div>
  
  <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dev.reconnoiter.internal"></a>Internal APIs</h2></div></div></div>
      
</div>
  <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm59688334048"></a>Hooks</h2></div></div></div>
    
    <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688332736"></a>Abitrary Hooks</h3></div></div></div>
 
 <p>Building a callout API makes sense for common, structured
 features in software, but occassionlly there is a need to provide
 somewhat arbitrary hook points after the software is designed
 and the noit_hooks system is what satisfies this need.</p>
 <p>The design goals here are somewhat specific in that we
 would like to allow for a large number of hook points at low cost
 when not instrumented.  As such, a hash lookup of registered hooks
 would be considered to expensive.  Additionally, we want to provide
 strong, compile-time type safety as it can be all to easy to hook
 something with a function with a slightly incorrect protoype that
 could result in disasterous corruption or crashes (or perhaps worse
 daftly subtle bugs that are punishing to troubleshoot).</p>
 <p>The hooks system is simple a set of two macros; one allowing
 for the declaration of function prototypes for registering and invoking
 a specific programmer-specifiec instrumentation point and the other
 providing an implementation of the registration and invocation
 routines.  Due to the nature of C, the macro calling conventions are
 less than elegant, but ultimately require no complicated implementation
 by the programmer.</p>
   <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688329056"></a>Hook Declaration</h4></div></div></div>
   <p>
   Declaring hooks is done by calling the NOIT_HOOK_PROTO macro with
   the name of the hook (a term that composes a valid C function name),
   the arguments it expects, the type of closure (usually a void *),
   and some variations on those themes that provide CPP enough info
   to construct an implementation with no programmer "programming."
   </p>
   <p>The declaration of a hook "foo" will yield in two functions:
   foo_hook_invoke and foo_hook_register.</p>
   <div class="example"><a name="idm59688327424"></a><p class="title"><b>Example 10.1. Declaring a foobarquux hook in a header.</b></p><div class="example-contents">
   
   <p>A foobarquux hook prototype that takes a struct timeval * argument.</p>
   <pre class="programlisting">
     NOIT_HOOK_PROTO(foobarquux, (struct timeval *now),
                     void *, closure, (void *closure, struct timeval *now));
   </pre>
   </div></div><br class="example-break">
   <div class="example"><a name="idm59688325408"></a><p class="title"><b>Example 10.2. Implementing a foobarquux hook in source.</b></p><div class="example-contents">
   
   <p>A foobarquux hok implementation that takes a struct timeval * argument.</p>
   <pre class="programlisting">
     NOIT_HOOK_IMPL(foobarquux, (struct timeval *now),
                    void *, closure, (void *closure, struct timeval *now),
                    (closure,now));
   </pre>
   </div></div><br class="example-break">
   </div>
   <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688323408"></a>Hook Usage</h4></div></div></div>
   <p>Once the hook is implemented, it can be used by the application
   and instrumented by code at runtime. In the below example, we'll
   invoke the foobarquux instrumentation and assuming no issues arise,
   we'll invoke the original foobarquux_work() function.</p>
   <div class="example"><a name="idm59688322080"></a><p class="title"><b>Example 10.3. Instrumenting a function conditionally.</b></p><div class="example-contents">
   
   <p>Before we instrument, suppose we have:</p>
   <pre class="programlisting">
     foobarquux_work();
   </pre>
   <p>Now we wish to allow programmers to add instrumentation
   immediately before this code that can conditionally prevent its
   executation:</p>
   <pre class="programlisting">
     struct timeval now;
     gettimeofday(&amp;now, NULL);
     if(NOIT_HOOK_CONTINUE ==
        foobarquux_hook_invoke(&amp;now))
       foobarquux_work();
   </pre>
   </div></div><br class="example-break">
   <p>If the hook should not conditionally cause or prevent code
   to run, the invoke function's return value can be ignored.</p>
   <p>In order to register a function that allows the above execution
   on every other subsequent execution one would provide the following:
   </p>
   <div class="example"><a name="idm59688318240"></a><p class="title"><b>Example 10.4. A sample instrumentation of foobarquux</b></p><div class="example-contents">
   
   <pre class="programlisting">
     static my_sample_hook(void *closure, struct timeval *now) {
       static int alt = 0;
       return (alt++ % 2) ? NOIT_HOOK_CONTINUE : NOIT_HOOK_DONE;
     }

     ...
       foobarquux_hook_register("sample", my_sample_hook, NULL);
     ...
   </pre>
   </div></div><br class="example-break">
   </div>
 </div>
    <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688316336"></a>Check Hooks</h3></div></div></div>
 
   <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688316112"></a>check_preflight</h4></div></div></div>
   <pre class="programlisting">
     noit_hook_return_t (*f)(void *closure, noit_module_t *self,
                             noit_check_t *check, noit_check_t *cause);
   </pre>
   <p>the check_preflight hook is invoked immediately prior to every
   check being performed.  The actual invocation of the check can be
   avoided by returning NOIT_HOOK_DONE instead of NOIT_HOOK_CONTINUE.
   </p>
   <p>The arguments to this function are the module of the check
   the check itself and the causal check (NULL if this check was not
   induced by the completion of another check), respectively.</p>
   <p>This instrumentation point can be used to audit intended check
   activity or prevent a check from running (such as an ACL).</p>
   </div>
   <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688312240"></a>check_postflight</h4></div></div></div>
   <p>The check_postflight hook is invoked immediately subsequent to
   a check being commenced.  Note that due to the asynchronous nature
   of Reconnoiter, it is highly unlikely that the check will have 
   completed by this time.</p>
   <p>The arguments to this function are the module of the check,
   the check itself and the causal check (NULL if this check was not
   induced by the completion of another check), respectively.</p>
   <p>Returning NOIT_HOOK_CONTINUE and NOIT_HOOK_DONE have the same
   effect for this instrumentation point.</p>
   </div>
 </div>
  </div>
  <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm59688309152"></a>Developing modules in C</h2></div></div></div>
      
      <p>As Reconnoiter is written in the C programming language, the native plugin development
            is done in C.  If C is not your preferred language, please see the sections regarding
            programming plugins in lua, Java and via external programs via the external module.</p>
      <p>In this section we will walk through a complete (yet simple) check module that reports a random number as a metric.</p>
      <p>Generally, a real check module would be much more complex requiring extensive use of other Reconnoiter APIs.</p>
      <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">You must not block in module code</h3>
      <p>Reconnoiter uses an evented system that relies on normal code to act in a non-blocking fashion.  Performing network operations, filesystem access or invoking third-party library calls can block the Reconnoier event loop and cause the system to malfunction.  Reconnoiter provides a robust suite of APIs and services to manage non-blocking IO and run blocking operations in asynchronous thread pools.  These APIs are discussed in <a class="xref" href="dev.reconnoiter.html#dev.reconnoiter.internal" title="Internal APIs">the section called &#8220;Internal APIs&#8221;</a>.</p>
      </div>
      <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688304368"></a>Starting your project</h3></div></div></div>
        
				<p>It is highly recommended that you start a new module based on the
example module available at <a class="ulink" href="https://github.com/circonus-labs/reconnoiter/tree/master/src/modules/example" target="_top"><em class="citetitle">src/modules/example</em></a>.</p>
        <p>Reconnoiter ships a confguration helper called <span class="command"><strong>noit-config</strong></span>.  This tool can help you determine how to build and install plugin modules.</p>
        <p>There are three basic components of a C module: a Makefile, a source file and a documentation file. There can be multiple source iles for more complicated project, but herein we will assume a single source file for a module.</p>
        <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688300896"></a>Module documentation</h4></div></div></div>
          
          <p>Reconnoiter module documentation is written in xml using a non-strict subset of docbook.  It describe the module, it's type, how it is loaded, the various confiruation parameters (including allowable values and default), and finally optional examples of the module in action.</p>
          <p>As all documentation is accessible in the <a class="ulink" href="https://github.com/circonus-labs/reconnoiter/tree/master/src/modules/" target="_top"><em class="citetitle">src/modules</em></a> directory in the reconnoiter repository, it is recommended that you reference that (and docbook documentation) for examples.</p>
          <p>While it is not recommended, producing an empty xml file as your module documentation is permitted, but may limit certain functionality.</p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688297344"></a>Writing code</h4></div></div></div>
          
					<p>Reconnoiter check modules have a few basic parts including code
                that executes as the module is loaded, for module-level configuration,
                initialization and to initiate a check.  We will take a guided tour through the
                example module to better undestand these parts and how they work.</p>

<pre class="programlisting">
/* Your copyright and license data here */

#include "noit_defines.h"
#include "noit_module.h"
#include "noit_check.h"
#include "noit_check_tools.h"
</pre>

<p>These are the minimal includes required to author a check module.</p>

<pre class="programlisting">
static noit_log_stream_t nlerr = NULL;
static noit_log_stream_t nldeb = NULL;

static int example_onload(noit_image_t *self) {
  if(NULL == (nlerr=noit_log_stream_find("error/example"))) nlerr = noit_error;
  if(NULL == (nldeb=noit_log_stream_find("debug/example"))) nldeb = noit_debug;
  return 0;
}
</pre>

<p>We'd like to be able to use Reconnoiter's logging infrastructure to note errors and debugging information that can be granularly controlled.  We declare them statically within our module and initialize them in our onload function (the first thing that runs).  Here we look for a configured log destination at "error/example" to assign our to our log stream <code class="code">nlerr</code>, but if one is not found, we'll fall back to the globally defined <code class="code">noit_error</code> log stream.</p>

<p>It is important to note that the <code class="code">onload</code> function is called in the parent (monitor) <span class="command"><strong>noitd</strong></span> before privileges are dropped.  If a module requires opening a device, priviledged socket or other task requiring escalate privileges it must be performed here.  All other module callbacks happen in the main process subsquent to dropping privileges.</p>

<p>This function must return 0 on success.  If a non-zero return value is provided, the module will not load.</p>

<pre class="programlisting">
static int example_config(noit_module_t *self, noit_hash_table *options) {
  return 0;
}
</pre>

<p>The <code class="code">noit.conf</code> file allows a configuration to be passed to a module as it is loaded.  This configuration is converted into a dictionary (represented as a <code class="code">noit_hash_table *</code>) with keys and values as C strings.  This dictionary is passed to the module instance by calling our <code class="code">example_config</code> function.</p>

<p>This function must return 0, a non-zero return value will cause the module to be unavailable.</p>

<pre class="programlisting">
static int example_init(noit_module_t *self) {
  return 0;
}
</pre>

<p>The initialization function is called after configuration.  This is the opportunity to perform boot-time configuration.</p>

<p>This function must return 0, a non-zero return value will cause the module to be unavailable.</p>

<pre class="programlisting">
struct example_check_info {
  noit_check_t *check;
  noit_module_t *self;
  int limit;
};

static int example_initiate(noit_module_t *self, noit_check_t *check,
                            noit_check_t *cause) {
  /* run on each check invocation */
  ...
  /* discussed in detail later */
}

static int example_initiate_check(noit_module_t *self, noit_check_t *check,
                                  int once, noit_check_t *cause) {
  struct example_check_info *ci;
  if(!check-&gt;closure)
    check-&gt;closure = calloc(1, sizeof(struct example_check_info));
  ci = check-&gt;closure;
  ci-&gt;check = check;
  ci-&gt;self = self;
  INITIATE_CHECK(example_initiate, self, check, cause);
  return 0;
}
</pre>

<p>When a check is first successfully configured and enabled in Reconnoiter, the module associated with that check is invoked once.  This can be confusing to users that would think the application would invoke the check according to the check's configured period.  In fact, it is the checks responsibility to run itself.  This might sound intimidating, but there are convenience functions and the separation provides some capabilities that more advanced modules leverage.</p>

<p>Given that your module is special, it is likely that you will need to store information along the instance of the check you are enabling.  Each <code class="code">noit_check_t</code> has a <code class="code">closure</code> that is provided for you to use as your context.  In this example, we declare a structure that is useful to our example module.  The <code class="code">int limit</code> is useful to the features and function of our module.  The two other structure elements are included out of best practice.  As module executiong becomes more complicated, you will find yourself with only your user context and finding the check and module will be necessary.</p>

<p>In this example, <code class="code">example_initiate_check</code> will be called when a check is first installed (not every <code class="code">period</code> milliseconds).  In this function, we setup our user context in <code class="code">check-&gt;closure</code>, set our other context elements and call a convenience macro called <code class="code">INITIATE_CHECK</code>.  The <code class="code">INITIATE_CHECK</code> macro will setup a recurrent job that will run <code class="code">example_initiate</code> at the frequency at which the check is configured. This two-phase initiation is considered best practice.</p>

<pre class="programlisting">
static int example_initiate(noit_module_t *self, noit_check_t *check,
                            noit_check_t *cause) {
  struct example_check_info *ci = check-&gt;closure;
  const char *limit = "0";
  struct timeval diff;

  BAIL_ON_RUNNING_CHECK(check);
  check-&gt;flags |= NP_RUNNING;
</pre>

<p>Exploring our <code class="code">example_initiate</code> more deeply, we collect our user context from <code class="code">check-&gt;closure</code> and setup some local variable in our C stack we'll need later.</p>

<p>The first critial step is refuse to run if the check is already running and then mark this check as running before proceeding.  The <code class="code">BAIL_ON_RUNNING_CHECK</code> does the former, and next we set the <code class="code">NP_RUNNING</code> bit in our check's flags.</p>

<pre class="programlisting">
  noit_hash_retrieve(check-&gt;config, "limit", strlen("limit"), (void **)&amp;limit);
  ci-&gt;limit = atoi(limit);
</pre>

<p>Our check's configuration (like out module's configuration) is a dictionary in a <code class="code">noit_hash_table</code> where keys and values are C strings.  In this example, we look for a config setting "limit" and convert that into a number and store it in our context.</p>

<p>You should evaluate the config each time your check runs as the configuration may have been changed at run-time by an operator since the last invocation.</p>

<pre class="programlisting">
  if(check-&gt;stats.inprogress.status) free(check-&gt;stats.inprogress.status);
  noit_check_stats_clear(check, &amp;check-&gt;stats.inprogress);
  gettimeofday(&amp;check-&gt;stats.inprogress.whence, NULL);
  sub_timeval(check-&gt;stats.inprogress.whence, check-&gt;last_fire_time, &amp;diff);
  check-&gt;stats.inprogress.duration = diff.tv_sec * 1000 + diff.tv_usec / 1000;
  check-&gt;stats.inprogress.available = NP_AVAILABLE;
  check-&gt;stats.inprogress.status = strdup("hello world");
</pre>

<p>Each check has a set of three <code class="code">stats_t</code> (a structure holding metadata about the execution of a check) structures: <code class="code">previous</code>, <code class="code">current</code> and <code class="code">inprogress</code>.  As a module author, you should never touch the previous or current <code class="code">stats_t</code> structures; operate only on the <code class="code">check-&gt;stats.inprogress</code>.</p>

<p>Walking through this example, we first clear our inprogress stats.  The reason we must explicitly free the status is because the last time we were invoked we allocated (via strdup) the status that's there; we own it, we allocated it, we free it.  We then calculate how long this check took to run (which should be pretty darn fast as we didn't do anything).  We proceed to set various key attributes in the inprogress structure: <code class="code">duration</code>, <code class="code">available</code>, and <code class="code">status</code>.  We then set our status (allocating via strdup). This completes the metadata of the check and we proceed on setting our metric(s).</p>

<pre class="programlisting">
  if(ci-&gt;limit) {
    int value = (int)(lrand48() % ci-&gt;limit);
    noit_stats_set_metric(check, &amp;check-&gt;stats.inprogress,
                          "random", METRIC_INT32, &amp;value);
    check-&gt;stats.inprogress.state = NP_GOOD;
  }
  else {
    noit_stats_set_metric(check, &amp;check-&gt;stats.inprogress,
                          "random", METRIC_INT32, NULL);
    check-&gt;stats.inprogress.state = NP_BAD;
  }
</pre>

<p>If the limit has been set (to something other than zero), we calculate a random integer and limit it to the requested range.  We take that and set a metric called "random" in our <code class="code">inprogress</code> <code class="code">stats_t</code> structure.  Notice we pass the addres of our integer and not the value.  This worked out well for us, so we set our state to "good."</p>

<p>If the limit was zero, we still want to pass the metric back, but we'd like to note that we couldn't not calculated it (you can't modulo by zero).  In this case we set the metric just as before, but pass <code class="code">NULL</code> in as the value.  We consider this an unsuccessful performance, so we set the state to "bad."</p>

<pre class="programlisting">
  noit_check_set_stats(check, &amp;check-&gt;stats.inprogress);
  check-&gt;flags &amp;= ~NP_RUNNING;

  return 0;
}
</pre>

<p>We set the stats on the check via the call to <code class="code">noit_check_set_stats</code>.  This step actually causes reconnoiter to log the data which is sent upstream.  You can think of this a "committing" the data.  Finally, we mark our check as no longer running.</p>

<pre class="programlisting">
static void example_cleanup(noit_module_t *self, noit_check_t *check) {
  struct example_check_info *ci = check-&gt;closure;
  if(ci) {
    free(ci);
  }
}
</pre>

<p>You may optionally provide a function to free the context for the check in the case when a check is disabled or deleted administratively during runtime. If you allocate a context, you should most likely implement this or you will risk leaking memory.</p>

<pre class="programlisting">
#include "example.xmlh"
noit_module_t example = {
  {
    .magic = NOIT_MODULE_MAGIC,
    .version = NOIT_MODULE_ABI_VERSION,
    .name = "example",
    .description = "a module to demonstrat module development",
    .xml_description = example_xml_description,
    .onload = example_onload
  },
  example_config,
  example_init,
  example_initiate_check,
  example_cleanup
};
</pre>

<p>This last declaration ties everything together.  This is the actual declaration of your module.  The name of the <code class="code">noit_module_t</code> variable must match the <code class="code">name</code> field.  The <code class="code">magic</code> and <code class="code">version</code> ensure that this module can only be loaded into a compatible <span class="command"><strong>noitd</strong></span>.</p>

<p>The <code class="code">#include</code> of the <code class="code">.xmlh</code> file might look odd, but we'll get to how that is auto-generated from your XML documetation when we discuss writing our Makefile.  This specific include file provide a define for the the XML documentation as a C string; in this example it is named <code class="code">example_xml_description</code>.  The rest of the structure assignements connect the functions we've already written into the module definition so that <code class="code">noitd</code> knows which functions to run.</p>
        </div>
        <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688250976"></a>Writing a Makefile</h4></div></div></div>
          
          <p>Building an C app that is more than a toy requires a build environment.  While it is possible to set up projects in an IDE, we will tour through a minimal build system using <span class="command"><strong>make</strong></span>.</p>
          <p>Our makefile has 4 goals:</p>
          <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Convert our documentation so that it can be included in our code.</p></li><li class="listitem"><p>Compile our code to objects.</p></li><li class="listitem"><p>Link our objects together into a loadable module.</p></li><li class="listitem"><p>Install the results.</p></li></ul></div>
          <p>The Makefile must start with some non-standard suffixes so that we can make general rules around building our parts.</p>
<pre class="programlisting">
.SUFFIXES: .lo .bundle .xml .xmlh .so
</pre>
          <p><code class="code">.lo</code> is used, by convention, to mean object code that has been compiled in an pointer-invariant manner (e.g. using the <code class="code">-fPIC</code> compiler option).  <code class="code">.bundle</code> and <code class="code">.so</code> are the expected file extensions of loadable modules on Mac OS X and all other UNIX and UNIX-like platforms, respectively.  Finally, to convert from our XML documentation to our customer XML header files, we teach <code class="code">make</code> about the <code class="code">.xml</code> and <code class="code">.xmlh</code> extensions.</p>

<pre class="programlisting">
CC=$(shell noit-config --cc)
CPPFLAGS=$(shell noit-config --cppflags)
SHCFLAGS=$(shell noit-config --shcflags)
MODULELD=$(shell noit-config --moduleld)
SHLDFLAGS=$(shell noit-config --shldflags)
MODULEEXT=$(shell noit-config --moduleext)
MODULESDIR=$(shell noit-config --modules-dir)
XML2H=$(shell noit-config --xml2h)
</pre>
          <p>Compiling, linking and processing XML are all quite dependent on your environment.  When the Reconnoiter product configureson your platform, it produces a helper application called <span class="command"><strong>noit-config</strong></span> that can regurgitate the originally determined options.  Here we save relevant commands and options into variables to use in our Makefile.</p>

<pre class="programlisting">
MODULES=example.$(MODULEEXT)

all:  $(MODULES)

</pre>
          <p>Next we make a list of the modules we wish to build and set the first (and default) target <code class="code">all</code> to depend on that list.  Now when you run <span class="command"><strong>make</strong></span> it will attempt to build the module.</p>

<pre class="programlisting">
.xml.xmlh:
  @$(XML2H) `echo $&lt; | sed -e 's/\.xml$$//;'`_xml_description &lt; $&lt; &gt; $@
</pre>

          <p>We define a rule to convert from our XML documentation to our custom <code class="code">.xmlh</code> inline include.  The resulting file is included in our module's source code.</p>

<pre class="programlisting">
example.lo: example.c example.xmlh
  $(CC) $(CPPFLAGS) $(SHCFLAGS) -o $@ -c $&lt;
</pre>

          <p>Next we define a rule to build an object from our source code.</p>

<pre class="programlisting">
example.$(MODULEEXT): example.lo
  $(MODULELD) $(SHLDFLAGS) -o $@ example.lo
</pre>

          <p>We then define a rule to build our module by linking the object(s) together.  This is the place where we would add additional library dependencies if our module leveraged 3rd-party libraried.</p>

          <p>At this point, we can run make an product a module that can be loaded into our <span class="command"><strong>noitd</strong></span>.</p>

<pre class="programlisting">
install:  $(MODULES)
  for i in $(MODULES); do \
    cp $$i $(DESTDIR)$(MODULESDIR)/$$i; \
    chmod 755 $(DESTDIR)$(MODULESDIR)/$$i; \
  done
</pre>

          <p>For sake of completeness, we can proide and <code class="code">install</code> target that installs the built module to the directory in which <span class="command"><strong>noitd</strong></span> was originally configured to delivery it's included modules.</p>

        </div>
      </div>
</div>
  <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm59688296448"></a>Developing modules in lua</h2></div></div></div>
      
      <p>Reconnoiter modules can be written in <a class="ulink" href="http://www.lua.org/" target="_top"><em class="citetitle">Lua</em></a>.  Modules implementing check types as well as more generic non-check related modules can be authored in lua.</p>
      <p>Due to Reconnoiter's event handling system, one must be careful when taking blocking actions in their lua modules as doing so can cause general malfunctions including watchdog timeouts where the process will be terminated and restarted.</p>
      <p>Several lua bindings are available under the <code class="code">noit</code> namespace are available to assist in leveraging the event system and supprting libraries.</p>
      <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688226192"></a>Installing lua modules</h3></div></div></div>
        
        <p>Site to site locations may vary, but the search path for lua is specific in the <code class="code">noit.conf</code> file where the lua loader is loaded.  Lua files should be installed relative to this path where modules namespaces are in their own directory heirarchy.  For example, <code class="code">noit.module.example</code> should be in a file <code class="code">noit/module/example.lua</code> relative to the search path.  In a typical Reconnoiter install, if the install prefix is <code class="code">/opt/noit/prod</code>, then this file would be <code class="code">/opt/noit/prod/libexec/noit/noit/module/example.lua</code>.</p>
        <p>Lua files are simply copied to this location and are available to be included via the noit configuration system.</p>
        <p>The lua loader itself should be loaded exactly once within the <code class="code">modules</code> section of the configuration:</p>
        <pre class="programlisting">
    &lt;loader image="lua" name="lua"&gt;
      &lt;config&gt;
        &lt;directory&gt;/opt/noit/prod/libexec/noit/?.lua&lt;/directory&gt;
      &lt;/config&gt;
    &lt;/loader&gt;
</pre>
        <p>Loading a lua module using that loader is also in the <code class="code">modules</code> section:</p>
        <pre class="programlisting">
    &lt;module loader="lua" name="example" object="noit.module.example"&gt;
      &lt;config&gt;&lt;/config&gt;
    &lt;/module&gt;
</pre>
      </div>
      <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688218176"></a>Basic lua checks</h3></div></div></div>
        
        <p>As with any check module in Reconnoiter, there are four basic elements: documentation, initialization, configuration and performing a check.  In lua modules, the documentation is actually coded and injected during the loading of the module.</p>
        <p>Every module should start with a <code class="code">module</code> declaration and documentation chunk wrapped in the <code class="code">onload</code> function.</p>
        <pre class="programlisting">
/* Your copyright and license data here */

module(..., package.seeall)

function onload(image)
  image.xml_description([=[
&lt;module&gt;
  &lt;name&gt;munin&lt;/name&gt;
  &lt;description&gt;&lt;para&gt;Report the seconds since epoch and a random number.&lt;/para&gt;&lt;/description&gt;
  &lt;loader&gt;lua&lt;/loader&gt;
  &lt;object&gt;noit.module.example&lt;/object&gt;
  &lt;moduleconfig /&gt;
  &lt;checkconfig /&gt;
&lt;/module&gt;
]=]);
  return 0
end
</pre>
        <p>The module should then specify an initialization command and a configuration command. The options passed to the configuration function are the config parameters specified relative to the module in the configuration file, not a specific check's configuration.</p>
        <pre class="programlisting">
function init(module)
  return 0
end

function config(module, options)
  return 0
end
</pre>

        <p>Lastly, the module should provide an <code class="code">initiate</code> functino that performs the check.</p>
        <pre class="programlisting">
function initiate(module, check)
  local now_seconds = noit.gettimeofday()
  check.metric_int32("seconds_since_epoch", now_seconds)
  check.metric_double("random", math.random())
  check.available()
  check.good()
  check.status("had a good day")
end
</pre>
    </div>
    <div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm59688211200"></a>Reconnoiter-specific lua</h3></div></div></div>
      
      <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688210688"></a>Module images and checks</h4></div></div></div>
        
        <p>Taking the <code class="code">initiation</code> function as an example, the first argument <code class="code">module</code> is of type <code class="code">noit_module_t</code> and the second argument <code class="code">check</code> is of type <code class="code">noit_check_t</code>.  Each of these types has several functions and attributes.</p>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688206720"></a><code class="code">noit_module_t.description([description])</code></h5></div></div></div>
                 <p>If an argument is provided, the description is updated to <code class="code">description</code>. The description is returned.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688204976"></a><code class="code">noit_module_t.name([name])</code></h5></div></div></div>
                 <p>If an argument is provided, the name is updated to <code class="code">name</code>. The name is returned.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688203344"></a><code class="code">noit_module_t.xml_description([xml])</code></h5></div></div></div>
                 <p>If an argument is provided, the XML description (documentation) is updated to <code class="code">xml</code>.  The XML description is returned.</p></div>

        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688201696"></a><code class="code">noit_check_t.available()</code></h5></div></div></div>
                 <p>Sets the check's <code class="code">available</code> field to <code class="code">NP_AVAILABLE</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688199744"></a><code class="code">noit_check_t.availability()</code></h5></div></div></div>
                 <p>Returns the check's current <code class="code">available</code> field.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688198176"></a><code class="code">noit_check_t.bad()</code></h5></div></div></div>
                 <p>Sets the check's <code class="code">state</code> field to <code class="code">NP_BAD</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688196224"></a><code class="code">noit_check_t.config</code></h5></div></div></div>
                 <p>A lua table representing the check's config dictionary.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688195056"></a><code class="code">noit_check_t.flags(...)</code></h5></div></div></div>
                 <p>This function takes a list of string flags and bitwise ORs them together to create a mask.  This function returns the check's current flags bitwise ANDed with the mask.</p>
                 <p>Possible string flags: <code class="code">NP_RUNNING</code>, <code class="code">NP_KILLED</code>, <code class="code">NP_DISABLED</code>, <code class="code">NP_UNCONFIG</code>, <code class="code">NP_TRANSIENT</code>, <code class="code">NP_RESOLVE</code>, <code class="code">NP_RESOLVED</code>, <code class="code">NP_SUPPRESS_STATUS</code>, <code class="code">NP_PREFER_IPV6</code>, <code class="code">NP_SINGLE_RESOLVE</code>, and <code class="code">NP_PASSIVE_COLLECTION</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688193520"></a><code class="code">noit_check_t.good()</code></h5></div></div></div>
                 <p>Sets the check's <code class="code">state</code> field to <code class="code">NP_GOOD</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688186736"></a><code class="code">noit_check_t.interpolate([in])</code></h5></div></div></div>
                 <p>This function accepts a string or a table whose values are strings.  It applies check interpolation using the checks attributes and config and returns a new interpolated string or a copy of the table whose values are interpolated, respectively.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688185376"></a><code class="code">noit_check_t.module</code></h5></div></div></div>
                 <p>A string representing the name of the module.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688184272"></a><code class="code">noit_check_t.metric(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> guessing at its type.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688182240"></a><code class="code">noit_check_t.metric_double(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing (if possible) the type to a 64-bit double.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688180240"></a><code class="code">noit_check_t.metric_int32(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing (if possible) the type to a signed 32-bit integer.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688178208"></a><code class="code">noit_check_t.metric_int64(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing (if possible) the type to a signed 64-bit integer.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688176176"></a><code class="code">noit_check_t.metric_string(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing the type to a string.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688174144"></a><code class="code">noit_check_t.metric_uint32(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing (if possible) the type to an unsigned 32-bit integer.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688172144"></a><code class="code">noit_check_t.metric_uint64(name, value)</code></h5></div></div></div>
                 <p>Set a metric named <code class="code">name</code> to the value <code class="code">value</code> forcing (if possible) the type to a unsigned 64-bit integer.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688170112"></a><code class="code">noit_check_t.metric_json(json)</code></h5></div></div></div>
                 <p>Take a fully-formed JSON document and set metrics from them as is done by the resmon module.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688168960"></a><code class="code">noit_check_t.name</code></h5></div></div></div>
                 <p>A string representing the name of the check.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688167744"></a><code class="code">noit_check_t.period</code></h5></div></div></div>
                 <p>An integer representing the period of the check in milliseconds.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688166528"></a><code class="code">noit_check_t.state()</code></h5></div></div></div>
                 <p>This function returns the state of the check.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688165424"></a><code class="code">noit_check_t.status(msg)</code></h5></div></div></div>
                 <p>This function sets the status of the check to <code class="code">msg</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688163808"></a><code class="code">noit_check_t.target</code></h5></div></div></div>
                 <p>A string representing the target of the check.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688162704"></a><code class="code">noit_check_t.target_ip</code></h5></div></div></div>
                 <p>A string representing the resolved target IP address of the check.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688161472"></a><code class="code">noit_check_t.timeout</code></h5></div></div></div>
                 <p>An integer representing the timeout of the check in milliseconds.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688160288"></a><code class="code">noit_check_t.unavailable()</code></h5></div></div></div>
                 <p>Sets the check's <code class="code">unavailable</code> field to <code class="code">NP_UNAVAILABLE</code>.</p></div>
      </div>
      <div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm59688210560"></a>Non-blocking network functions</h4></div></div></div>
        
        <p>All networking functions in lua modules should use the <code class="code">noit.socket</code> function to retrieve a socket with non-blocking methods attached.  These sockets support both UDP and TCP as well as SSL over TCP.</p>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688156528"></a><code class="code">noit.socket(ipaddress[, protocol])</code></h5></div></div></div>
                 <p>Creates and returns a socket for the Internet family (IPv4 or IPv6) to which the <code class="code">ipaddress</code> belongs. The <code class="code">protocol</code> argument can be "udp" or "tcp," defaulting to "tcp" is omitted. Returns an object of type <code class="code">noit.eventer</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688153952"></a><code class="code">noit.socket(family[, protocol])</code></h5></div></div></div>
                 <p>Creates and returns a socket of type <code class="code">family</code> (either "inet" or "inet6"). The <code class="code">protocol</code> argument can be "udp" or "tcp," defaulting to "tcp" is omitted. Returns an object of type <code class="code">noit.eventer</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688151376"></a><code class="code">noit.eventer:accept()</code></h5></div></div></div>
                 <p>Accept a new socket from an existing listening socket. Returns a new non-blocking socket of type <code class="code">noit.eventer</code></p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688149872"></a><code class="code">noit.eventer:bind(address, port)</code></h5></div></div></div>
                 <p>Bind the current socket to the specified <code class="code">address</code> and <code class="code">port</code>. Returns two values, a return code (0 on success) and a possible error message.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688147872"></a><code class="code">noit.eventer:close()</code></h5></div></div></div>
                 <p>Closes the socket.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688146752"></a><code class="code">noit.eventer:connect(ipaddress, port)</code></h5></div></div></div>
                 <p>Establish a connection to the specified <code class="code">ipaddress</code> and <code class="code">port</code>. Returns two values, a return code (0 on success) and a possible error message.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688144656"></a><code class="code">noit.eventer:listen(backlog)</code></h5></div></div></div>
                 <p>Use listen(2) to place the current socket in listening mode (ready to accept connections).  The <code class="code">backlog</code> argument is passed to the listen system call.  Returns three arguments: a return code (0 on success), and possibly the <code class="code">errno</code> and error message in the event of a failure condition.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688142448"></a><code class="code">noit.eventer:own()</code></h5></div></div></div>
                 <p>Each <code class="code">noit.eventer</code> object to a lua coroutine.  If you pass an object to another coroutine to use, that coroutine should claim ownership of the object by invoking this function.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688140688"></a><code class="code">noit.eventer:read(length)</code></h5></div></div></div>
                 <p>Read <code class="code">length</code> bytes from the socket and return them as a string.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688139168"></a><code class="code">noit.eventer:read(delimiter)</code></h5></div></div></div>
                 <p>Read bytes up to and including the string specified by <code class="code">delimiter</code> return them as a string.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688137536"></a><code class="code">noit.eventer:recv(length)</code></h5></div></div></div>
                 <p>Read a packet of up to <code class="code">length</code> bytes.  Returns two values: the length of the packet read and the contents of the packet.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688135968"></a><code class="code">noit.eventer:send(pkt)</code></h5></div></div></div>
                 <p>Send te string <code class="code">pkt</code> over the socket.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688134352"></a><code class="code">noit.eventer:sendto(pkt, address, port)</code></h5></div></div></div>
                 <p>Send te string <code class="code">pkt</code> over the socket to the specified <code class="code">address</code> and <code class="code">port</code>.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688131936"></a><code class="code">noit.eventer:setsockopt(type, value)</code></h5></div></div></div>
                 <p>Call the system setsockopt(2) function with the specified <code class="code">value</code>.  Supported values for <code class="code">type</code> are <code class="code">"SO_BROADCAST"</code>, <code class="code">"SO_REUSEADDR"</code>, <code class="code">"SO_KEEPALIVE"</code>, <code class="code">"SO_LINGER"</code>, <code class="code">"SO_OOBINLINE"</code>, <code class="code">"SO_SNDBUF"</code>, <code class="code">"SO_RCVBUF"</code>, <code class="code">"SO_DONTROUTE"</code>, <code class="code">"SO_RCVLOWAT"</code>, <code class="code">"SO_RCVTIMEO"</code>, <code class="code">"SO_SNDLOWAT"</code>, and <code class="code">"SO_SNDTIMEO"</code>.  Returns two values: a return code (0 on success) and a possible error message.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688130960"></a><code class="code">noit.eventer:ssl_upgrade_socket(cert,key,ca,ciphers)</code></h5></div></div></div>
                 <p>Upgrade a connected socket to SSL.  The <code class="code">cert</code>, <code class="code">key</code>, and <code class="code">ca</code> arguments specify the paths to files containing the certificate, key, and CA chain, respectively.  <code class="code">ciphers</code> is a list of ciphers as understood by OpenSSL.  Returns two values, a return code (0 on success) and a possible error message.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688121776"></a><code class="code">noit.eventer:ssl_ctx()</code></h5></div></div></div>
                 <p>Return the associated SSL context (of type <code class="code">noit.eventer.ssl_ctx</code>).</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688120208"></a><code class="code">noit.eventer:write(body)</code></h5></div></div></div>
                 <p>Write the string <code class="code">body</code> over the socket.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688118640"></a><code class="code">noit.eventer.ssl_ctx:ciphers</code></h5></div></div></div>
                 <p>A lua table containing the names ciphers that have been negotiated on the context.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688117536"></a><code class="code">noit.eventer.ssl_ctx:current_cipher</code></h5></div></div></div>
                 <p>The name of the currently used cipher.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688116320"></a><code class="code">noit.eventer.ssl_ctx:error</code></h5></div></div></div>
                 <p>The error encountered when attempting to validate the peer.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688115104"></a><code class="code">noit.eventer.ssl_ctx:end_time</code></h5></div></div></div>
                 <p>The time at which the peer's certificate will no longer be valid (expire).  This time is measured in seconds since 1970.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688113872"></a><code class="code">noit.eventer.ssl_ctx:issuer</code></h5></div></div></div>
                 <p>The issuer of the peer's certificate.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688112768"></a><code class="code">noit.eventer.ssl_ctx:method</code></h5></div></div></div>
                 <p>The current SSL method being used.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688111616"></a><code class="code">noit.eventer.ssl_ctx:san_list</code></h5></div></div></div>
                 <p>The subject alternate names of the peer's certificate.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688110400"></a><code class="code">noit.eventer.ssl_ctx:subject</code></h5></div></div></div>
                 <p>The subject of the peer's certificate.</p></div>
        <div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm59688109296"></a><code class="code">noit.eventer.ssl_ctx:start_time</code></h5></div></div></div>
                 <p>The time at which the peer's certificate begins validaity (issuance date).  This time is measured in seconds since 1970.</p></div>
      </div>
    </div>
</div>
  <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm59688107888"></a>Developing modules in Java</h2></div></div></div>
      
</div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part IV. Development </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Part V. Reference</td></tr></table></div></body></html>
